# Mawaru Station Front/Backend repo
Исходный код интернет-радио [Mawaru Station](http://mawaru.party/)

### С чем имеем дело
Так сложилось исторически, что сервер интернет-радиостанций [liquidsoap](http://liquidsoap.info) не умеет в нормальную отдачу информации о том, что вообще внутри него происходит. Есть только два канала связи с ним -  telnet и unix-socket.
Для адекватного вывода информации необходима своя прослойка. 
Это - один из вариантов её реализации с применением NоdeJS и React.

#### На чем работает Mawaru Station
* Liquidsoap 1.3.3
* Icecast 2.4.3
* Сожержимое этого репозитория

## Back-end

### Icecast2
Установить и настроить айскаст2 несложно.

#### Установка
```
apt-get install icecast2
```
#### Настройка
Файл конфигурации лежит тут: `/etc/icecast2/icecast.xml`

Примерное содержание должно быть таким

```
<icecast>
    <location>Moon</location>
    <admin>icemaster@localhost</admin>
    <limits>
        <clients>1000</clients>
        <sources>8</sources>
        <queue-size>524288</queue-size>
        <client-timeout>30</client-timeout>
        <header-timeout>15</header-timeout>
        <source-timeout>10</source-timeout>
        <burst-on-connect>1</burst-on-connect>
        <burst-size>65535</burst-size>
    </limits>

    <authentication>
        <source-password>---</source-password><!-- пароль -->
        <relay-password>---</relay-password><!-- пароль -->
        <admin-user>---</admin-user><!-- логин -->
        <admin-password>---</admin-password><!-- пароль -->
    </authentication>

    <hostname>---</hostname><!-- Имя сервера -->
    
    <listen-socket>
        <port>---</port><!-- порт -->
    </listen-socket>

    <http-headers>
        <header name="Access-Control-Allow-Origin" value="*" />
    </http-headers>

    <mount>
        <mount-name>/---</mount-name><!-- Имя маунта -->
        <username>---</username><!-- логин -->
        <password>---</password><!-- пароль -->
        <charset>cp1251</charset><!-- Лучше так, меньше проблем с тегами -->
    </mount>

    <fileserve>1</fileserve>

    <paths>
        <basedir>/usr/share/icecast2</basedir>
        <logdir>/var/log/icecast2</logdir>
        <webroot>/usr/share/icecast2/web</webroot>
        <adminroot>/usr/share/icecast2/admin</adminroot>
        <alias source="/" destination="/status.xsl"/>
    </paths>

    <logging>
        <accesslog>access.log</accesslog>
        <errorlog>error.log</errorlog>
        <loglevel>3</loglevel>
        <logsize>10000</logsize>
    </logging>

    <security>
        <chroot>0</chroot>
    </security>
</icecast>
```
После правки конфига, созраняем его и делаем `service icecast2 restart` \
Проверяем доступность, вбив в браузере в адресной строке адрес:порт, если появилась статистика сервера, значит можно идти дальше.

### Liquidsoap
Тут уже не все так просто и придется повозиться

#### Установка

Всегда есть простой путь
```
apt-get install liquidsoap
```
Но стоит помнить одну вещь - в репозиториях устаревшая версия 1.1.1. Mawaru Station работает на версии 1.3.3 и я не могу гарантировать, что код совместим с ней. К тому же, у этой версии много багов (из того, что у меня было - некорректные веса при рандомизации треков и джинглов, играет порой по три джингла и один трек,  не работал смарт кроссфейд ну и что-то еще, я уже и не помню). \
Поэтому я рекомендовал бы поставить жидкое мыло из исходников. Правда придется запастись терпением, чтобы установить все зависимости. Исходники и инструкции: https://github.com/savonet/liquidsoap

#### Настройка

Нормальных гайдов по конфигурированию почти нет, поэтому построчно разберу свой файл конфига и на его основе можно будет создать свой.
Итак, создаем папку, где будем хранить треки, логи и сам конфиг (например `/var/radio`).
Далее создаем там файл `nano start.liq` и приступаем к написанию конфигурации.

##### Включаем логи
Думаю, тут пояснять ничего не нужно.
```
set("log.file.path","/var/radio/radios.log")
set("log.stdout", true)
set("log.level",3) 
```


##### Кодировка тегов
Только так и никак иначе. 
```
set("tag.encodings",["UTF-8"])
```

##### Включаем telnet
Если хотите иметь доступ извне, то **127.0.0.1** нужно заменить на реальный айпи сервера. Но стоит помнить, что **никакой защиты у телнета нет и любой Васян сможет взять контроль за вашим вещанием**
```
set("server.telnet", true)
set("server.telnet.bind_addr","127.0.0.1")
set("server.telnet.port",5657)
set("server.telnet.reverse_dns",false)
```

##### Активируем возможность вещать вживую.
Для этого нам понадобится софт типа SAM Broadcaster. Инструкции для него можно нагуглить без проблем.
```
set("harbor.bind_addr","0.0.0.0")
live = audio_to_stereo(input.harbor(id="---", port=---, password="---", "---"))
liveover = audio_to_stereo(input.harbor(port=---, password="---", "---"))
```
Если хотите полностью перекрыть поток, то айди указывается. Если хотите вещать поверх - айди опускается. \
Последние кавычки - имя маунта для соединения (его нужно будет вбивать в программе для вещания, вместе с портом и паролем).

##### Рерайтим теги
Иногда нам не нужно, чтобы определенный плейлист транслировал теги. Например, в джинглах. Можно их переписать на свое сообщение. \
Пример того, как это работает на Mawaru Station:
```
def jin_tag(j)
   rewrite_metadata([("title","Mawaru radio!")], update=false, strip=true, j)
end
```


##### Формируем плейлисты
В корневой папке создаем папки для музыки и скидываем туда треки. Можно целыми каталогами, liquidsoap вытащит все, что найдет. \
Например так:
```
#Music playlists
day = audio_to_stereo(playlist("/var/radio/music"))
night = audio_to_stereo(night_tag(playlist("/var/radio/night")))

#Jingle playlist
jin = audio_to_stereo(jin_tag(playlist("/var/radio/jin")))
```
Обратите внимние, что если мы хотим рерайтить теги, то нужно не забыть указать это перед playlist.

##### Раскидывем веса для плейлистов
Например, нам нужно чередовать "Три трека, один джингл". \
Пишем в конфиг что-то такое:
```
day = rotate(weights=[1,3],[jin,day])
night = rotate(weights=[1,3],[jin,night])
```


##### Формируем автономный поток
Тут стоит остановиться подробнее.
```
music = fallback([
request.queue(id="request"),
switch(track_sensitive=false, 
[
({0h00m00s-3h59m59s},day), 
({4h00m00s-6h59m59s},night), 
({7h00m00s-23h59m59s},day)
])])
```
`fallback` - В случае проблем переключаемся на следующий готовый трек \
`switch` - Переключение между готовыми треками. \
`track_sensitive=false` - Запрещаем ждать конца текущего трека для перехода к следующему (особенно актуально для часовых отбивок). \
Дальше мы формируем само расписание. Тут вроде бы и так все очевидно.

##### Формируем живой поток
Теперь все нужно заставить играть и учесть возможность вещать живьем
```
ready_air = fallback(id="STREAM", track_sensitive = false,([fallback.skip(input=live,fallback.skip(input=music,blank())) ]))
ready_air = add([ready_air,amplify(5.0,liveover)])															
radio = smart_crossfade(ready_air)
```
Все тоже, что и в предыдущем сегменте. Отмечу, что тут `track_sensitive=false` обязателен, иначе лайв не начнется до конца текущего трека в эфире. `fallback.skip` гарантирует, что переключении источников при возврате мы не попадем на середину трека, на котором он был прерван. Полезная штука. \
Код второй строки включает возможность вещать поверх текущего потока (объявления, реклама, вот это все). `amplify` - усиливает громкость. Это **важно**, иначе ваш голос не будет слышно. Значение же придется выставлять методом проб и ошибок. \
Третья строка включает плавные переходы между треками (но иногда это работает через жопу, генерируя забавный результат, если не хотите - удалите эту строку). \
`radio` в итоге и будет нашим потоком, который учел все возможные ситуации и обеспечит нам бесперебойную работу в эфире.

##### Подключаем часы
```
clock.assign_new(id="Mawaru",[radio])
```

##### Отдаем поток айскасту
Сюда нужно вбить значения из конфига айскаста.
```
output.icecast(%mp3(bitrate=128, samplerate = 44100, stereo = true, id3v2 = true), host = "127.0.0.1", port = 8000, name="---", genre="mixed", url="---", description="---", user="---", password = "---", mount = "/---", radio)

```
Тут можно указать все нужные маунты (у меня их четыре).

##### Запускаем вещание
Последний шаг. Скрипт готов, сохраняем его и, убедившись что находимся в папке с ним, вбиваем:
```
nohup liquidsoap start.liq &
```
Если все правильно, то айскаст начнет отдавать то, что вещает жидкое мыло и можно уже идти слушать поток.


### Mawaru Engine
Грубо называть это движком, но я ничего лучше не придумал, потому хрен с ним.

#### Quick rundown
Разберем, как общаться с liquidsoap. 

Ничего особо сложного или сверхестественного, достаточно изучить то, какие ответы возвращает telnet и правильно их парсить.
Однако некоторые вещи не очевидны. \
\
Например, на запрос `mountpoint.status` вернется только on/off в зависимости играет ли поток. Информацию о текущем треке вытаскивать нужно из `mountpoint.metadata`(желательно) или `playlist.next`(не стоит).\
\
Если хочется управлять сервером через API, то стоит помнить, что перемешивание треков происходит через `playlist.reload` (его так же нужно вызывать при добавлении новых треков в каталог с музыкой. А вот пропуск через `mountpoint.skip`, вне зависимости от того, какой плейлист сейчас "в воздухе". Кстати, если маунтов несколько, то не важно к какому делать запрос.\
\
OGG/Vorbis, по моему мнению, предпочтительнее для работы с тегами, но это мое мнение.\
\
Исполнителя и название трека мы берем из тегов OGG потока. Если тегов нет, то в название трека летит название файла (на фронте исполнитель заменяется заглушкой).\
\
Все данные, полученные от нескольких запросов пишутся в MongoDB, откуда формируются в один JSON и отдаются по единственному роуту. Выглядит это примерно [так](http://mawaru.party:3001/status). Запись в БД необходима, чтобы не дергать телнет каждый раз и отдавать пользователю только статические данные. 

#### Last.fm
Обложки берутся через API ласт.фм. Вытаскивается самый первый ответ и из него берется картинка. Во избежание бана приложения, все общение с ласт.фм выполняет сервер, раз в несколько секунд получая обложку и перезаписывая ее. Клиент же общается только с сервером напрямую, дабы не было огромного количества запросов. Я не особо уверен в текущей реализации этого функционала, но он вроде бы работает без сбоев. \
При нулевом ответе, клиенту отдается "заглушка". Она же отдается в момент пауз, джинглов и плейлитов, рерайтящих инфо о потоке. Не забудьте изменить все пути на свои в CoverDelivery.js

#### Telegram Bot
Управление эфиром осуществляется через бота, исходный код которого пока что написан на пхп и до сих пор не переписан. Как только у меня дойдут до этого руки, его исходные коды попадут сюда. При желании можно написать веб версию админки, раскомментировав роуты в index.js. Но о секурности/авторизации вам придется заботиться самим. Бот в телеграме же привязан к аккаунту и никому другому не позволяет управлять потоком, только получать информацию о нем.


## Front-end
Тут все банально, это простенький SPA на реакте. Устанавливаем зависимости, правим конфигурацию, билдим, используем любимый веб-сервер для доставки статики клиентам. Некоторые особенности я распишу при релизе следующей версии. 

## TODO
* База треков. Давно хотел это сделать.
* Рейтинг и статистика. Теперь, когда есть своя прослойка, то можно легко собрать статистику по трекам, а так же дать слушателям возможности оценивать их.
* Чат на сокетах.

